<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.IO" #>
<#@ assembly name="System.Design" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="VSLangProj" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Resources.Tools" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ include file="CommandSchema.ttinclude" #>
<#@ include file="CommandReader.ttinclude" #>
<#@ output extension=".txt" #><#
var serviceProvider = this.Host as IServiceProvider;
var dte = serviceProvider.GetService(typeof(DTE)) as DTE;
string projectDir = Host.ResolveAssemblyReference("$(ProjectDir)");
XmlDocument doc = new XmlDocument();
// Load prototype.xml
doc.Load(Path.Combine(projectDir, @"./Commands.xml"));

List<CustomCommand> cmds = Read(doc);

var manager = new Manager(Host);
var t4DirInfo = new FileInfo(Host.TemplateFile).Directory;
  
Generate(cmds, manager, t4DirInfo);
manager.Process();
#><#+
private void Generate(List<CustomCommand> cmds, Manager manager, DirectoryInfo t4DirInfo) 
{
    var hostServiceProvider = (IServiceProvider) Host;
    var dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
    var projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    string resxFileName = Path.Combine(t4DirInfo.FullName, "CommandResources.resx");
    using (ResXResourceWriter resx = new ResXResourceWriter(resxFileName)) 
    {
	    foreach (CustomCommand cmd in cmds) 
	    {
		    manager.Start(cmd.name + ".cs");
		    //manager.StartNewFile(cmd.name + ".cs");
            manager.WriteLine("namespace " + projectItem.ContainingProject.Name);
            manager.WriteLine("{\n");
            manager.Write("\tpublic partial class ");
		    if (cmd.isComposite)
                manager.WriteLine(cmd.name);
            else
                manager.WriteLine(cmd.name);

            manager.Write("\t{");
            manager.WriteLine("");
            string displayName = cmd.name + "Name";
            manager.WriteLine("\t\tpublic string DisplayName => CommandResources." + displayName + ";");
            resx.AddResource(displayName, cmd.displayName);

            foreach (CustomProperty prop in cmd.properties)
            {
                manager.Write("\t\tpublic virtual ");
                manager.Write(prop.type);
                manager.Write(" ");
                manager.Write(prop.name);
                manager.Write(" { get; set; }");
                if (prop.mapping == null)
                    Write("Property " + prop.name + " is not mapped to db.");

                manager.WriteLine("// Mapping " + (prop.mapping == null ? "Not mapped to db" : prop.mapping));
            }

            manager.WriteLine("\n");

            // Default protected constructor
            manager.Write("\t\tprotected ");
            manager.Write(cmd.name);
            manager.WriteLine("() {}");

            // Public constructor
            manager.Write("\t\tpublic ");
            manager.Write(cmd.name);
            manager.WriteLine("(string test) {}");

            manager.WriteLine("\t}\n");
            manager.Write("}");
        }

        resx.Generate();
        resx.Close();
	}

    //manager.StartNewFile(resxFileName);
    manager.Start(resxFileName);
    manager.Write(File.ReadAllText(resxFileName));
    //manager.EndBlock();
    
    manager.Process();
    SetAndRunResXFileCodeGenerator(t4DirInfo, resxFileName);
}

private void SetAndRunResXFileCodeGenerator(DirectoryInfo t4DirInfo, string fileName, string nameSpace = "")
{
    var hostServiceProvider = (IServiceProvider) Host;
    var dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
    var projectItem = dte.Solution.FindProjectItem(fileName);
    projectItem.Properties.Item("CustomTool").Value = "PublicResXFileCodeGenerator";
    projectItem.Properties.Item("CustomToolNamespace").Value = nameSpace;
    ((VSProjectItem)projectItem.Object).RunCustomTool();
}

class Manager 
{
    
    private class FileBlock
    {
        internal StringBuilder file = new StringBuilder();
        internal String name;

        public FileBlock(String name)
        {
            this.name = name;
        }
    }

    private List<FileBlock> _fileBlocks = new List<FileBlock>();
    private EnvDTE.DTE dte;
    private EnvDTE.ProjectItem templateProjectItem;
    private String outputPath;
    private Action<IEnumerable<String>> projectSyncAction;


    internal Manager(ITextTemplatingEngineHost host) 
    {
        var hostServiceProvider = (IServiceProvider) host;
        if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
        dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
        if (dte == null)
            throw new ArgumentNullException("Could not obtain DTE from host");
        templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
        outputPath = Path.GetDirectoryName(host.TemplateFile);
        projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
    }

    public void Start(String filename) 
    {
        _fileBlocks.Add(new FileBlock(filename));
    }

    public void Write(string text)
    {
        _fileBlocks[_fileBlocks.Count - 1].file.Append(text);
    }

    public void WriteLine(string text)
    {
        _fileBlocks[_fileBlocks.Count - 1].file.AppendLine(text);
    }

    private bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public void Process()
    {
        List<String> generatedFileNames = new List<String>();
        foreach (FileBlock fb in _fileBlocks)
        {
            var fileName = Path.Combine(outputPath, fb.name);
            CreateFile(fileName, fb.file.ToString());
            generatedFileNames.Add(fileName);
        }

        projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
    }

    private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames)
    {
        var keepFileNameSet = new HashSet<String>(keepFileNames);
        var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.Name) + ".";
        var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
        foreach (EnvDTE.ProjectItem item in templateProjectItem.ProjectItems) 
        {
            // Get current items under the template
            projectFiles.Add(item.get_FileNames(0), item);
        }

        // Remove unused items
        foreach (var pair in projectFiles)
        {
            if (!keepFileNameSet.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                pair.Value.Delete();
        }

        // Add missing files
        foreach (String filename in keepFileNameSet) 
        {
            if (!projectFiles.ContainsKey(filename)) 
            {
                templateProjectItem.ProjectItems.AddFromFile(filename);
            }
        }
    }

}
#>