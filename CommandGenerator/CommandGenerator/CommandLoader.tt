<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.IO" #>
<#@ assembly name="System.Design" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="VSLangProj" #>
<#@ assembly name="Microsoft.VisualStudio.Editor" #>
<#@ import namespace="Microsoft.VisualStudio.Editor" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="VSLangProj" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Resources" #>
<#@ import namespace="System.Resources.Tools" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ include file="CommandSchema.ttinclude" #>
<#@ include file="CommandReader.ttinclude" #>
<#@ output extension=".txt" #><#
var serviceProvider = this.Host as IServiceProvider;
var dte = serviceProvider.GetService(typeof(DTE)) as DTE;
string projectDir = Host.ResolveAssemblyReference("$(ProjectDir)");
XmlDocument doc = new XmlDocument();
// Load prototype.xml
doc.Load(Path.Combine(projectDir, @"./Commands.xml"));

List<CustomCommand> cmds = Read(doc);

var manager = new Manager(Host);
var t4DirInfo = new FileInfo(Host.TemplateFile).Directory;
  
Generate(cmds, manager, t4DirInfo);
manager.Process();
#><#+
private void WriteMapping(CustomCommand cmd, Manager manager, ProjectItem projectItem)
{
    var mappingName = cmd.name + "Mapping";
    var mappingFileName = mappingName +".cs";
    manager.Start(mappingFileName);

    manager.WriteLine("using NHibernate.Mapping.ByCode.Conformist;");
    manager.WriteLine("");

    manager.WriteLine("");
    manager.WriteLine("namespace " + (projectItem.ContainingProject.Name + cmd.cmdNamespace) + ".Mappings");
    manager.WriteLine("{");
    
    // Class in the namespace
    manager.PushIndent();

    manager.WriteLine();
    manager.Write("public partial class ");
    manager.Write(mappingName);
    manager.Write(" : SubclassMapping<");
    manager.Write(cmd.name);
    manager.WriteLine(">");

    manager.WriteLine("{");
    manager.WriteLine();

    manager.PushIndent();

    manager.Write("public ");
    manager.Write(mappingName);
    manager.WriteLine("()");
    manager.WriteLine("{");

    manager.PushIndent();

    manager.Write("DiscriminatorValue(\"");
    manager.Write(cmd.name);
    manager.WriteLine("\");");
    manager.WriteLine();

    foreach (CustomProperty prop in cmd.properties)
    {
        if (prop.mapping == null) continue;

        manager.Write(prop.mapping);
        manager.Write("(x => x."); 
        manager.Write(prop.name);
        manager.WriteLine(", map =>");
        manager.WriteLine("{");
        manager.PushIndent();

        if (prop.mapping != "Property")
        {
            manager.Write("map.NotNullable(");
            manager.Write(prop.canBeNull.ToString().ToLowerInvariant());
            manager.WriteLine(");");
        }

        manager.WriteLine("map.Column(\"" + prop.name + "\");");

        manager.RemoveIndent();

        manager.WriteLine("});");
        manager.WriteLine();
    }

    manager.WriteLine();
    manager.WriteLine("InitializeOther();");

    manager.RemoveIndent();

    manager.WriteLine("}"); // end constructor

    manager.WriteLine();
    manager.WriteLine("partial void InitializeOther();");

    manager.RemoveIndent();

    manager.WriteLine();
    manager.WriteLine("}"); // end class

    // End of the class
    manager.RemoveIndent();

    manager.WriteLine("}"); // End namespace
}

private void WriteCommand(CustomCommand cmd, Manager manager, ProjectItem projectItem)
{
    manager.Start(cmd.name + ".cs");

	manager.Write("using ");
    manager.Write(projectItem.ContainingProject.Name + cmd.parentNamespace);
    manager.WriteLine(";");

    manager.Write("using ");
    manager.Write(projectItem.ContainingProject.Name); // For resources
    manager.WriteLine(";");

    manager.WriteLine("");
    manager.WriteLine("namespace " + (projectItem.ContainingProject.Name + cmd.cmdNamespace));
    manager.WriteLine("{");
    manager.WriteLine("");
    manager.Write("\tpublic partial class ");
    manager.Write(cmd.name);
    manager.Write(" : ");
    manager.WriteLine(cmd.parentName);

    manager.Write("\t{");
    manager.WriteLine("");
    string displayName = cmd.name + "Name";
    manager.WriteLine("\t\tpublic override string DisplayName => CommandResources." + displayName + ";");
    manager.WriteLine("\t\tpublic override bool IsPersistable => " + cmd.isPersistable.ToString().ToLowerInvariant() + ";");
                
    foreach (CustomProperty prop in cmd.properties)
    {
        manager.Write("\t\tpublic virtual ");
        manager.Write(prop.type);
        manager.Write(" ");
        manager.Write(prop.name);
        manager.Write(" { get; set; }");
        if (prop.mapping == null)
            Write("Property ", prop.name, " is not mapped to db.");

        manager.WriteLine("// Mapping " + (prop.mapping == null ? "Not mapped to db" : prop.mapping));
    }

    manager.WriteLine("");
    manager.WriteLine("");

    // Default protected constructor
    manager.Write("\t\tprotected ");
    manager.Write(cmd.name);
    manager.WriteLine("() {}");

    // Public constructor
    manager.Write("\t\tpublic ");
    manager.Write(cmd.name);
    manager.WriteLine("(string test) {}");

    manager.WriteLine("\t}");
    manager.WriteLine("");
    manager.Write("}");
}

private void Generate(List<CustomCommand> cmds, Manager manager, DirectoryInfo t4DirInfo) 
{
    var hostServiceProvider = (IServiceProvider) Host;
    var dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    string resxFileName = Path.Combine(t4DirInfo.FullName, "CommandResources.resx");
    using (ResXResourceWriter resx = new ResXResourceWriter(resxFileName)) 
    {
	    foreach (CustomCommand cmd in cmds) 
	    {
		    WriteCommand(cmd, manager, projectItem);
            WriteMapping(cmd, manager, projectItem);
            string displayName = cmd.name + "Name";
            resx.AddResource(displayName, cmd.displayName);
        }

        resx.Generate();
        resx.Close();
	}

    //manager.StartNewFile(resxFileName);
    manager.Start(resxFileName);
    manager.Write(File.ReadAllText(resxFileName));
    //manager.EndBlock();
    
    manager.Process();
    SetAndRunResXFileCodeGenerator(t4DirInfo, resxFileName);
}

private void SetAndRunResXFileCodeGenerator(DirectoryInfo t4DirInfo, string fileName, string nameSpace = "")
{
    var hostServiceProvider = (IServiceProvider) Host;
    var dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
    var projectItem = dte.Solution.FindProjectItem(fileName);
    projectItem.Properties.Item("CustomTool").Value = "PublicResXFileCodeGenerator";
    projectItem.Properties.Item("CustomToolNamespace").Value = nameSpace;
    ((VSProjectItem)projectItem.Object).RunCustomTool();
}

class Manager 
{
    
    private class FileBlock
    {
        internal StringBuilder file = new StringBuilder();
        internal String name;

        public FileBlock(String name)
        {
            this.name = name;
        }
    }

    private List<FileBlock> _fileBlocks = new List<FileBlock>();
    private EnvDTE.DTE dte;
    private EnvDTE.ProjectItem templateProjectItem;
    private String outputPath;
    private Action<IEnumerable<String>> projectSyncAction;
    private int _indent = 0;
    private bool _isNewLine = true;


    internal Manager(ITextTemplatingEngineHost host) 
    {
        var hostServiceProvider = (IServiceProvider) host;
        if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
        dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
        if (dte == null)
            throw new ArgumentNullException("Could not obtain DTE from host");
        templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
        outputPath = Path.GetDirectoryName(host.TemplateFile);
        projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
    }

    public void PushIndent() 
    {
        ++_indent;
    }

    public void RemoveIndent() 
    {
        --_indent;
    }

    public void Start(String filename) 
    {
        _fileBlocks.Add(new FileBlock(filename));
    }

    public void Write(string text)
    {
        if (_isNewLine)
        {
            for (int i = 0; i < _indent; ++i)
                _fileBlocks[_fileBlocks.Count - 1].file.Append("\t");

            _isNewLine = false;
        }

        _fileBlocks[_fileBlocks.Count - 1].file.Append(text);
    }

    public void WriteLine()
    {
        _fileBlocks[_fileBlocks.Count - 1].file.AppendLine("");
        _isNewLine = true;
    }

    public void WriteLine(string text)
    {
        if (_isNewLine)
        {
            for (int i = 0; i < _indent; ++i)
                _fileBlocks[_fileBlocks.Count - 1].file.Append("\t");
        }

        _fileBlocks[_fileBlocks.Count - 1].file.AppendLine(text);
        _isNewLine = true;
    }

    private bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
        {
            CheckoutFileIfRequired(fileName);
            File.WriteAllText(fileName, content);
            //AddToSourceControlIfRequired(fileName);
        }
    }

    public void Process()
    {
        List<String> generatedFileNames = new List<String>();
        foreach (FileBlock fb in _fileBlocks)
        {
            var fileName = Path.Combine(outputPath, fb.name);
            CreateFile(fileName, fb.file.ToString());
            generatedFileNames.Add(fileName);
        }

        projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        templateProjectItem.ContainingProject.Save();
    }

    private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames)
    {
        var keepFileNameSet = new HashSet<String>(keepFileNames);
        var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.Name) + ".";
        var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
        foreach (EnvDTE.ProjectItem item in templateProjectItem.ProjectItems) 
        {
            // Get current items under the template
            projectFiles.Add(item.get_FileNames(0), item);
        }

        // Remove unused items
        foreach (var pair in projectFiles)
        {
            if (!keepFileNameSet.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                pair.Value.Delete();
        }

        // Add missing files
        foreach (String filename in keepFileNameSet) 
        {
            if (!projectFiles.ContainsKey(filename)) 
            {
                templateProjectItem.ProjectItems.AddFromFile(filename);
            }
        }
    }

    private void CheckoutFileIfRequired(String fileName) 
    {
        var sc = dte.SourceControl;
        if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
            sc.CheckOutItem(fileName);
    }

    private void AddToSourceControlIfRequired(String fileName) 
    {
        var sc = dte.SourceControl;
        if (sc != null && !sc.IsItemUnderSCC(fileName))
            dte.ExecuteCommand("Team.Git.AddToSourceControl", fileName);
    }

}
#>